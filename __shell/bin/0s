#! /usr/bin/env tclsh

###############################################################################
# 0s: utilities/shortcuts for the system

set home $::env(HOME)
if {{root} eq $::tcl_platform(user)} { set home /home/b }
source $home/bin/lib.tcl
unset home

need notify-send rg \
     fnottctl \
     waylock \
     dracut \
     rsync xbps-query \
     0snooze-bat 0snooze-temper snooze

set SUDO /usr/bin/sudo

###############################################################################

proc _nrep {name} {
  # helper: replacement id for notify-send
  catch {exec fnottctl list | rg ": $name" -r {}} id ret
  if {0 != [dict get $ret -code]} {
    return {}
  }
  return "-r $id"
}

###############################################################################

proc bat {} {
  set device BAT0
  set crit 5
  set lo 20
  set hi 80
  set notify "notify-send [_nrep bat]"

  set dir /sys/class/power_supply/$device
  set capacity [readfile $dir/capacity]
  set status [readfile $dir/status]

  switch -- [string index $status 0] {
    {D} {
      if {$capacity <= $crit} {
        exec {*}$notify -u critical -i battery-010 bat $capacity%
      } elseif {[expr {$lo - 5}] <= $capacity && $capacity <= $lo} {
        exec {*}$notify -u normal -i battery-020 bat $capacity%
      }
    }
    {C} {
      if {$hi <= $capacity && $capacity <= [expr {$hi + 2}]} {
        exec {*}$notify -u low -i battery-080-charging bat $capacity%
      }
    }
  }
}

###############################################################################

proc bye {arg} {
  global SESS SUDO

  proc kill {} {
    catch {exec pkill dbus-daemon}
    catch {exec pkill dbus-launch}
    catch {exec pkill pipewire-pulse}
    catch {exec pkill pipewire}
    catch {exec pkill wireplumber}
  }

  proc save {} {
    global LOGW LOGX

    foreach f "$LOGW $LOGX" {
      if {[file exists $f]} {
        file rename -force -- $f $f.old
      }
    }
  }

  proc sync {} {
    exec 0s temper
  }

  switch -- $arg {
    k - o - lock {
      puts {0s: locking...}
      if {{w} eq $SESS} {
        set locker waylock
        catch {exec ps a | rg $locker | rg -qv " rg .*$locker"} _ ret
        if {0 == [dict get $ret -code]} {
          return
        }
        set args {
          -fork-on-lock
          -fail-color 0xa32c2d
          -init-color 0x16161d
          -input-color 0x575a61
        }
        catch {exec $locker {*}$args}
      }
    }
    e - l - q - x - logout {
      puts {0s: logging out...}
      save
      kill
      exec pkill [lindex [split $::env(DESKTOP_SESSION) /] end]
    }
    z - sleep - suspend {
      puts {0s: sleeping...}
      #sync
      exec $SUDO /bin/zzz
    }
    b - r - reboot {
      puts {0s: rebooting...}
      save
      #sync
      kill
      exec $SUDO /bin/reboot
    }
    h - s - shutdown {
      puts {0s: shutting down...}
      save
      #sync
      kill
      exec $SUDO /bin/halt
    }
    default {
      ufail {bye k|o|lock | e|l|q|x|logout | z|sleep|suspend | b|r|reboot | h|s|shutdown}
    }
  }
}

###############################################################################

proc cpu {args} {
  set gov [lindex $args 0]
  set epb [lindex $args 1]
  set dir /sys/devices/system/cpu
  set fgov cpufreq/scaling_governor
  set fepb power/energy_perf_bias
  set govs [lsort [readfile $dir/cpu0/cpufreq/scaling_available_governors]]
  set usage "cpu _|high|low|[string map {{ } |} $govs] \[0-15\]"

  switch -- $gov {
    {} {
      puts "[readfile $dir/cpu0/$fgov] [readfile $dir/cpu0/$fepb]"
      exit 0
    }
    h - hi - high - fast - top { set gov performance; set epb 0 }
    l - lo - low  - slow - bot { set gov powersave; set epb 15 }
    c { set gov conservative }
    o { set gov ondemand }
    w { set gov powersave }
    p { set gov performance }
    s { set gov schedutil }
    u { set gov userspace }
  }
  if {0 > [lsearch -exact $govs $gov]} {
    puts stderr "bad gov: $gov"
    ufail $usage
  }
  if {{} ne $epb && (![string is integer $epb] || $epb < 0 || 15 < $epb)} {
    puts stderr "bad epb: $epb"
    ufail $usage
  }

  try {
    exec -- >/dev/null 2>/dev/null /usr/bin/ls /root
  } on error e { fail {sudo required} }

  set cur [readfile $dir/cpu0/$fgov]
  if {$cur eq $gov} {
    puts "gov (NO CHANGE): $gov"
  } else {
    puts "gov: $cur -> $gov"
    foreach p [glob -directory $dir {cpu[0-7]}] {
      try {
        set h [open "$p/$fgov" w]; puts $h $gov; close $h
      } on error e { fail "$e" }
    }
  }

  if {{} eq $epb} {
    exit
  }
  set cur [readfile $dir/cpu0/$fepb]
  if {$cur eq $epb} {
    puts "epb (NO CHANGE): $epb"
  } else {
    puts "epb: $cur -> $epb"
    foreach p [glob -directory $dir {cpu[0-7]}] {
      try {
        set h [open "$p/$fepb" w]; puts $h $epb; close $h
      } on error e { fail "$e" }
    }
  }
}

###############################################################################

proc doze {{sec 60}} {
  global SUDO

  set threshold 10
  if {[expr {5 > $sec}]} {
    fail {check interval too low}
  }
  if {[expr {1800 < $sec}]} {
    fail {check interval too high}
  }
  set f /sys/class/power_supply/BAT0/capacity
  while true {
    exec sleep $sec
    set perc [readfile $f]
    if {[expr {$perc < $threshold}]} {
      exec $SUDO /bin/zzz
      return
    }
  }
}

###############################################################################

proc dracut {ver} {
  global SUDO

  set dir /lib/firmware
      #-i $::env(HOME)/opt/firmware/rtl8761bu_fw $d/rtl_bt/rtl8761bu_fw.bin \
      #-i $::env(HOME)/opt/firmware/rtl8761bu_config $d/rtl_bt/rtl8761bu_config.bin \
  try {
    exec -- >@stdout $SUDO /usr/bin/dracut \
      -i $dir/i915/kbl_dmc_ver1_04.bin $dir/i915/kbl_dmc_ver1_04.bin \
      -i $dir/i915/kbl_guc_70.1.1.bin $dir/i915/kbl_guc_70.1.1.bin \
      -i $dir/i915/kbl_huc_4.0.0.bin $dir/i915/kbl_huc_4.0.0.bin \
      -i $dir/intel/ibt-17-16-1.ddc $dir/intel/ibt-17-16-1.ddc \
      -i $dir/intel/ibt-17-16-1.sfi $dir/intel/ibt-17-16-1.sfi \
      -i $dir/iwlwifi-9000-pu-b0-jf-b0-46.ucode $dir/iwlwifi-9000-pu-b0-jf-b0-46.ucode \
      -i $dir/rtl_bt/rtl8761bu_fw.bin $dir/rtl_bt/rtl8761bu_fw.bin \
      -i $dir/rtl_bt/rtl8761bu_config.bin $dir/rtl_bt/rtl8761bu_config.bin \
      --force \
      -a "crypt dm lvm resume" \
      -o "btrfs" \
      /boot/initramfs-${ver}_c.img ${ver}_c
  } on error e { fail "$e" }
}

###############################################################################

proc save {} {
  global TMPD

  set dst $::env(HOME)/bak/save
  set nam [exec hostname]
  set tmp ${nam}_[clock format [clock seconds] -gmt true -format %y%m%d-%H%M%S]
  set src $TMPD/$tmp
  set zip $tmp.tgz
  set want "$::env(HOME)/cfg/*dotfiles \
            $::env(HOME)/.gnupg/*gnupg \
            $::env(HOME)/.ssh/*ssh"

  proc msg {s} { puts "### $s ###" }

  proc sep {} { puts "--------------------" }

  proc prep {src nam tmp} {
    if {[file isdirectory $src]} {
      file delete -force $src
    }
    file mkdir $src
    set f [open $src/LOG w]; puts $f $tmp; close $f
    sep
    puts "created $src\nsaving \"$nam\" customisations:"
  }

  proc copy {src} {
    upvar 1 want want

    # there cannot be asterisk (*) anywhere except as file*name separator
    # as specified in this declaration. see copy()
    foreach i $want {
      lassign [split $i *] f n
      if {{} eq $n} {
        regsub {^\.(.+)$} [file tail $f] {\1} m
        set n $m
      }
      if {![file readable $f]} {
        msg "invalid file $f"
        continue
      }
      if {[file readable $src/$n]} {
        msg "name \"$n\" already exists"
        continue
      }
      if {[file isfile $f]} {
        if {[catch {exec cp -d $f $src/$n}]} {
          msg "error copying $f"
          continue
        }
      } elseif {[file isdirectory $f]} {
        if {[catch {exec rsync -lr --exclude=.git $f $src/$n}]} {
          msg "error copying $f"
          continue
        }
        set n $n/
      } else {
        msg "$f is neither file nor dir"
        continue
      }
      puts "* $f  ($n)"
      set p [open $src/LOG a]; puts $p "$f * %n"; close $p
    }
  }

  proc etc {src} {
    exec cp /etc/fstab >$src/fstab
    puts "* fstab"
    exec lsmod >$src/lsmod
    puts "* lsmod"
    exec tail -n +1 {*}[glob /etc/modprobe.d/*] >$src/modprobe
    puts "* modprobe"
    exec tail -n +1 {*}[glob /etc/wpa_supplicant/wpa_supplicant-wl*] >$src/wpa
    puts "* wpa"
    exec tail -n +1 {*}[glob /etc/X11/xorg.conf.d/*] >$src/xorg
    puts "* xorg"
    exec ls "$::env(HOME)/opt/" >$src/opt
    puts "* ~/opt/"
    exec ls "$::env(HOME)/opt/" >$src/opt
    puts "* ~/opt/"
    exec cp /boot/EFI/refind/refind.conf $src/refind
    puts "* refind"
    exec xbps-query --list-pkgs >$src/installed
    puts "* packages installed"
    exec ls /var/service/ >$src/services
    puts "* services enabled"
  }

  proc save {src nam dst} {
    cd $src/..
    if {[catch {exec tar czf $dst $nam}]} { fail "error zipping" }
  }

  proc fin {src zip dst} {
    if {[file isdirectory $src]} { file delete -force $src }
    puts "removed $src"
    set p [open |[list du -hs $dst/$zip] r]
    regsub {^(\S+).+$} [read $p] {\1} size
    close $p
    sep
    puts "$zip ($size) saved in $dst"
  }

  prep $src $nam $tmp
  copy $src
  etc  $src
  save $src $tmp $dst/$zip
  fin  $src $zip $dst
}

###############################################################################

proc snooze {} {
  proc dream {name} {
    set awake [catch {exec ps x \
                      | rg "snooze .* 0s $name\$" \
                      | rg -v { rg }}]
    if {$awake} {
      exec 0snooze-$name &
    } else {
      puts {snooze $name already running}
    }
  }
  dream bat
  #dream temper
}

###############################################################################

proc temper {} {
  global TMPD
  # taken from https://www.verot.net/firefox_tmpfs.htm

  set where $TMPD
  set flag .unpacked
  set what mozilla/firefox
  set name g5dqc9ek.default-default

  proc base {name} {
    return [lindex [file split $name] end]
  }

  #set once "\"$::env(XDG_DATA_HOME)/$what/sessions/default.yml \
  #            $::env(XDG_DATA_HOME)/bak/${what}_session.yml\""
  #         parent               link  stat   vola
  set cont "\"$::env(HOME)/.$what          $name _$name $where/[base $what]\" \
            \"$::env(XDG_CACHE_HOME)/$what $name _$name $where/[base $what]-cache\""

  proc log {msg} {
    global ME LOGW

    set f [open $LOGW a]
    puts $f "$ME: $msg"
    close $f
  }

  proc to_disk {link stat flag} {
    #global LOGW

    log {omitting to-disk rsync messages}
    # to emit: exec >>&$LOGW
    if {[catch {exec >&/dev/null rsync --archive --verbose --delete --exclude $flag ./$link/ ./$stat/}]} {
      log {error copying to disk}
    }
  }

  proc to_mem {stat link flag} {
    log {omitting to-mem rsync messages}
    if {[catch {exec >&/dev/null rsync --archive ./$stat/ ./$link/}]} {
      log {error copying to mem}
    }
    # touch flag
    close [open $link/$flag a]
  }

  proc backup {src dst} {
    file copy -force -- $src $dst
  }

  proc refresh {root link stat vola} {
    upvar 1 flag flag

    file mkdir $vola
    file attributes $vola -permissions 00700
    cd $root
    if {{link} ne [file type $link] || $vola ne [file readlink $link]} {
      file rename $link $stat
      file link $link $vola
    }
    if {[file exists $link/$flag]} {
      to_disk $link $stat $flag
      return
    }
    to_mem $stat $link $flag
  }

  file mkdir $where
  #foreach i $once {
  #  set src [lindex $i 0]
  #  set dst [lindex $i 1]
  #  log "(once) $src -> $dst"
  #  backup $src $dst
  #}
  foreach i $cont {
    set root [lindex $i 0]
    set link [lindex $i 1]
    log "(cont) $root/$link"
    refresh $root $link [lindex $i 2] [lindex $i 3]
  }
}

###############################################################################

set arg [lindex $::argv 0]
if {0 == [llength [info procs $arg]]} {
  ufail {bat|bye|doze|dracut|cpu|save|snooze|temper
  bat     battery alert
  bye     stop session       lock|logout|sleep|reboot|shutdown
 #cpu     scale cpu          _|high|low|governors [0-15]
  doze    auto sleep         [5-1800]
  dracut  compile initramfs  KERNEL_VERSION
  save    backup data
  snooze  scheduled exec
  temper  www data to tmpfs}
}
$arg {*}[lrange $::argv 1 end]

